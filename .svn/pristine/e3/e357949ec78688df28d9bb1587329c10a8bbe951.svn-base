package ch1;
import java.util.*;

interface Lookup<T> {
	// use interfaces to provide different designs
	// use interfaces for peripheral abilities of a class, and not its central identity
	
	// specify WHAT the class is doing, but not HOW
	
	// 1. all variable declaration are implicitly "public static final"
	// 2. all methods are implicitly "public abstract"
	// 3. uses "implements"
	// 4. can extend only other interfaces
	// 5. cannot be instantiated
	// 6. all methods of an interface must be defined (all properties needs to be implemented by subclasses)
	// 7. interfaces contain no method implementation 
	// 8. can contain nested class and interface declarations
	// 9. cannot have constructors
	
	
	/* Return the value associated with the name, or
	 * null if there is no such value */
	T find(String name);
	T find();
	//T clear(String name);
}

interface Lookdown<T> {
	// use interfaces to provide different designs
	// use interfaces for peripheral abilities of a class, and not its central identity
	
	// specify WHAT the class is doing, but not HOW
	
	// 1. all variable declaration are implicitly "public static final"
	// 2. all methods are implicitly "public abstract"
	// 3. uses "implements"
	// 4. can extend only other interfaces
	// 5. cannot be instantiated
	// 6. all methods of an interface must be defined (all properties needs to be implemented by subclasses)
	// 7. interfaces contain no method implementation 
	// 8. can contain nested class and interface declarations
	// 9. cannot have constructors
	
	
	/* Return the value associated with the name, or
	 * null if there is no such value */
	T find(String name);
	T find();
	//T clear(String name);
}

class ArrayLookup implements Lookup<Integer>, Lookdown<Integer> {
	private String[] names;
	private Integer[] values;
	public ArrayLookup(){
		names = new String[3];
		names[0] = "one";
		names[1] = "two";
		names[2] = "three";
		
		values = new Integer[3];
		values[0] = 1;
		values[1] = 2;
		values[2] = 3;
		
	}
	public Integer find(String name) {
		for (int i = 0; i < names.length; i++) {
			if (names[i].equals(name))
				return values[i];
		}
		// not found
		return null;
	}
	
	public Integer find() {
		return 0;
	}
	
}

class ListLookup implements Lookup<Integer>, Lookdown<Integer> {
	private List<String> names;
	private List<Integer> values;
	public ListLookup(){
		names = new ArrayList<String>();
		names.add("one");
		names.add("two");
		names.add("three");
		
		values = new ArrayList<Integer>();
		values.add(1);
		values.add(2);
		values.add(3);
		
	}
	public Integer find(String name) {
		for (int i = 0; i < names.size(); i++) {
			if (names.get(i).equals(name))
				return values.get(i);
		}
		// not found
		return null;
	}
	
	public Integer find() {
		return 0;
	}
	
}

public class Test_Interface{
	// usage of a wildcard: "?" = of unspecified type, of some type
	// limit usage of objects type to Number
	// public static void processValues(String[] names, Lookup<? extends Number> table) {
	// Number value = table.find(names[i]);
	
	public static void processValues(String[] names, Lookup<?> table) {
		for (int i = 0; i < names.length; i++) {
		Object value = table.find(names[i]);
		if (value != null)
			System.out.println(value);
			}
		}

	public static void main(String args[]){
		/*
		Lookup<Integer> al = new ArrayLookup();
		Lookup<Integer> ll = new ListLookup();
		String [] names = new String[1];
		names[0]="two";
		System.out.println("First:");
		TestInterfaces.processValues(names, al);
		System.out.println("Second:");
		TestInterfaces.processValues(names, ll);
		*/
	}
}